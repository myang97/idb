<!DOCTYPE html>
<meta charset="utf-8">
<style>
.link {
  stroke: #ccc;
}

.node text {
  pointer-events: none;
  font: 10px sans-serif;
}

.legend rect {
  fill:white;
  stroke:black;
  opacity:0.8;
}


</style>

<h1 class=title>WeebMD.me Visualization</h1>
<body>

<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.17.1/axios.min.js"></script>
<script src="d3.legend.js"></script>
<script>
var animes = [];
var mangas = [];
var characters = [];
var actors = [];
var promises = [];
var instance = axios.create({
    baseURL: 'http://www.weebmd.me/api/',
    headers: {'Accept':'application/vnd.api+json' , 'content-type':'application/vnd.api+json'}
});

function getCharacters(id) {
    return instance.get('animes/'+id+'/characters', {
            crossdomain: true,
        });
}
function getActors(id) {
    return instance.get('animes/'+id+'/actors', {
            crossdomain: true,
        });
}
function getMangas(id) {
    return instance.get('animes/'+id+'/mangas', {
            crossdomain: true,
        });
}

let randomPage = Math.floor(Math.random() * 129) + 1 

instance.get("animes?page[number]=" + randomPage + "&page[size]=5", {
      crossdomain: true,
    }).then((response) => {
        animes = response.data.data
        for (let anime of animes) {
            promises.push(getCharacters(anime.id));
            promises.push(getActors(anime.id));
            promises.push(getMangas(anime.id));
        }
        console.log(promises);
        axios.all(promises).then(axios.spread(function (...responses) {
            for (let response of responses) {
                let data = response.data.data
                if (data.length) {
                    switch (data[0].type) {
                        case 'characters':
                            characters = characters.concat(data);
                            break;
                        case 'actors':
                            actors = actors.concat(data);
                            break;
                        case 'mangas':
                            mangas = mangas.concat(data);
                            break;
                    }
                }
            }

            var width = 1250,
            height = 800

            var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);

            var force = d3.layout.force()
                .gravity(0.1)
                .distance(100)
                .charge(-500)
                .size([width, height]);

            console.log(animes);
            console.log(characters);
            console.log(mangas);
            console.log(actors);

            var nodes = animes.map(function(i) {
                return {
                    index: 'anime'+i.id,
                    name: i.attributes.title,
                    color: "red",
                    size: 10,
                    type: 'anime'
                };
            });
            nodes = nodes.concat(mangas.map(function(i) {
                return {
                    index: 'manga'+i.id,
                    name: i.attributes.title,
                    color: 'yellow',
                    size: 10,
                    type: 'manga',
                };
            }));
            nodes = nodes.concat(characters.map(function(i) {
                return {
                    index: 'character'+i.id,
                    name: i.attributes.name,
                    color: 'purple',
                    size: 5,
                    type: 'character'
                };
            }));
            nodes = nodes.concat(actors.map(function(i) {
                return {
                    index: 'actor'+i.id,
                    name: i.attributes.name,
                    color: 'blue',
                    size: 5,
                    type: 'actor'
                };
            }));

            var links = [];

            for (let i = 0; i < animes.length; i++) {
                for (let j =0; j < animes[i].relationships.mangas.data.length; j++) {
                    let target = nodes.find(function(node) {
                        return node.index == 'manga'+animes[i].relationships.mangas.data[j].id
                    });
                    if (target) {
                        links.push({
                            source: nodes[i],
                            target: target
                        });
                    }
                }
                for (let j =0; j < animes[i].relationships.characters.data.length; j++) {
                    let target = nodes.find(function(node) {
                        return node.index == 'character'+animes[i].relationships.characters.data[j].id
                    });
                    if (target) {
                        links.push({
                            source: nodes[i],
                            target: target
                        });
                    }
                }
            }

            for (let i = 0; i < characters.length; i++) {
                for (let j =0; j < characters[i].relationships.actors.data.length; j++) {
                    let target = nodes.find(function(node) {
                        return node.index == 'actor'+characters[i].relationships.actors.data[j].id
                    });
                    if (target) {
                        links.push({
                            source: nodes[animes.length+mangas.length+i],
                            target: target
                        });
                    }
                }
                for (let j =0; j < characters[i].relationships.mangas.data.length; j++) {
                    let target = nodes.find(function(node) {
                        return node.index == 'manga'+characters[i].relationships.mangas.data[j].id
                    });
                    if (target) {
                        links.push({
                            source: nodes[animes.length+i],
                            target: target
                        });
                    }
                }
            }

            force
                .nodes(nodes)
                .links(links)
                .start();

            var link = svg.selectAll(".link")
                .data(links)
                .enter().append("line")
                .attr("class", "link");

            var node = svg.selectAll(".node")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(force.drag);

            node.append("circle")
                .attr("r", function(d) {return d.size })
                .attr("fill", function(d) { return d.color })
                .attr("data-legend",function(d) { return d.type})

            node.append("text")
                .attr("dx", 12)
                .attr("dy", ".35em")
                .text(function(d) { return d.name });


            legend = svg.append("g")
                .attr("class","legend")
                .attr("transform","translate(50,30)")
                .style("font-size","12px")
                .call(d3.legend)

            force.on("tick", function() {
                link.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });
                node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
            });
        }));

    }).catch(function (error) {
        console.log(error);
    });



</script>